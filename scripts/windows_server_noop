#!/usr/bin/env python
from Queue import Empty

from multiprocessing.connection import Listener
import time
import os
import sys
import logging


# import dragon wrapper
current_dir = os.path.dirname(os.path.realpath(__file__))
mod_path = os.path.join(current_dir, '..', 'src')
sys.path.append(mod_path)
from dragonfly_speech_recognition.wrapper import DragonflyWrapper

FORMAT = '%(asctime)s %(module)s  [%(levelname)s] %(message)s'
logging.basicConfig(format=FORMAT)
logging.getLogger().setLevel(logging.DEBUG)
logger = logging.getLogger(__name__)

# make dragonfly less verbose
logging.getLogger('engine').setLevel(logging.INFO)
logging.getLogger('grammar').setLevel(logging.INFO)
logging.getLogger('compound.parse').setLevel(logging.INFO)


class SpeechServer(object):
    def __init__(self):
        address = ("0.0.0.0", 8000)
        self._listener = Listener(address)
        self._dragon = DragonflyWrapper()

    def spin(self):
        logger.info('windows server started listening on port %s', self._listener.address)
        while True:
            try:
                conn = self._listener.accept()
                self.process_connection(conn)
            except KeyboardInterrupt:
                logger.warn('keyboard interrupt')
                break
            except:
                logger.exception('speech exception')

            conn.close()


    def process_connection(self, conn):
        print 'connection accepted from', self._listener.last_accepted

        msg = conn.recv()
        assert msg[0] == 'set'
        description = msg[1]
        spec = msg[2]
        choices = msg[3]
        self._dragon.set_grammar(spec, choices)


        while self._dragon.results.empty():
            time.sleep(.1)
            if conn.poll():
                try:
                    print conn.recv()
                except EOFError:
                    # connection closed
                    break
            self._dragon.spin_once()

        try:
            result = self._dragon.results.get_nowait()
        except Empty:
            sys.exit('no result')

        if not self._dragon.results.empty():
            raise Exception('Multiple results received')

        # filter all extras with _ because they are private
        result = {
            "result": result.node.value(),
            "choices": {k: v for (k, v) in result.extras.items() if not k.startswith('_')}
        }

        logger.info('result: %s', result)
        conn.send(result)
        conn.close()


server = SpeechServer()
server.spin()

